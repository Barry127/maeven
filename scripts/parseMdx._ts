import fm from 'front-matter';
import fs from 'fs';
import path from 'path';
import prettier from 'prettier';
//@ts-ignore
import shorthash from 'shorthash';
import { getPagesPaths, paths } from './paths';

const pageTemplate = fs.readFileSync(
  path.join(__dirname, 'templates', 'Page.template'),
  'utf8'
);
const routerTemplate = fs.readFileSync(
  path.join(__dirname, 'templates', 'Router.template'),
  'utf8'
);

interface Tree {
  title: string;
  type: 'node';
  children: (Tree | Leaf)[];
  sortKey?: string;
}

interface Leaf {
  title: string;
  type: 'leaf';
  fileHash: string;
  path: string;
  sortKey?: string;
  root?: boolean;
}

interface FrontMatterData {
  title?: string;
  path?: string;
  sortKey?: string;
}

export function parseMdx() {
  const tree: Tree = {
    title: 'root',
    type: 'node',
    children: []
  };

  getPagesPaths().forEach((pagePath) => {
    const page = fs.readFileSync(pagePath, 'utf8');
    const name = path
      .basename(pagePath)
      .slice(0, -path.extname(pagePath).length);

    const meta = fm<FrontMatterData>(page);
    const hash = shorthash.unique(page);
    const mdxFile = `${hash}.mdx`;
    const tsxFile = `${hash}.tsx`;

    const metaData: Leaf = {
      title: meta.attributes.title || name,
      type: 'leaf',
      fileHash: hash,
      path:
        meta.attributes.path ||
        pagePath.slice(paths.pages.length + 1, -path.extname(pagePath).length),
      sortKey: meta.attributes.sortKey
    };

    const tsxFileContent = pageTemplate
      .replace('{{FILENAME}}', `./${mdxFile}`)
      .replace('{{META}}', JSON.stringify(metaData));

    fs.writeFileSync(path.join(paths.generated, mdxFile), meta.body);
    fs.writeFileSync(
      path.join(paths.generated, tsxFile),
      prettier.format(tsxFileContent, { singleQuote: true, parser: 'babel' })
    );

    const menuPath = metaData.path.split('/');

    if (menuPath.length === 1) {
      metaData.root = true;
      tree.children.push(metaData);
      tree.children.sort(sortTree);
    } else {
      menuPath.pop();
      let currentTree = tree;
      menuPath.forEach((title) => {
        const index = currentTree.children.findIndex(
          (node) => node.type === 'node' && node.title === title
        );
        const newNode: Tree = {
          title,
          type: 'node',
          children: []
        };

        if (index === -1) {
          currentTree.children.push(newNode);
          currentTree.children.sort(sortTree);
          currentTree = newNode;
        } else {
          if (currentTree.children[index].title !== newNode.title) {
            (currentTree.children[index] as Tree).children.push(newNode);
            currentTree.children.sort(sortTree);
            currentTree = newNode;
          } else {
            currentTree = currentTree.children[index] as Tree;
          }
        }

        currentTree.children.push(metaData);
        currentTree.children.sort(sortTree);
      });
    }
  });
  return tree;
}

export function generateRouter(tree: Tree) {
  let imports = '';
  let routes = `<Route exact path="/"><Page${
    (tree.children[0] as Leaf).fileHash
  } /></Route>\n`;

  generateRoutes(tree);
  const routerFileContent = routerTemplate
    .replace('{{IMPORTS}}', imports)
    .replace('{{ROUTES}}', routes);

  fs.writeFileSync(
    path.join(paths.generated, 'Router.tsx'),
    prettier.format(routerFileContent, { singleQuote: true, parser: 'babel' })
  );

  function generateRoutes(tree: Tree) {
    tree.children.forEach((node) => {
      if (node.type === 'node') {
        generateRoutes(node);
      } else {
        imports += `import { Page as Page${node.fileHash} } from './${node.fileHash}';\n`;
        routes += `<Route path="/${node.path}"><Page${node.fileHash} /></Route>`;
      }
    });
  }
}

function sortTree(a: Leaf | Tree, b: Leaf | Tree) {
  if (
    (a.type === 'leaf' && a.root) ||
    (b.type === 'leaf' && b.root && a.type !== b.type)
  )
    return a.type === 'node' ? 1 : -1;

  const aSort = a.sortKey || a.title;
  const bSort = b.sortKey || b.title;
  return aSort > bSort ? 1 : -1;
}
